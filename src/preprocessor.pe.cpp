#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <algorithm>
#include <vector>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <omp.h>
#include "common.h"

using namespace std;

/**
 * Author: Kun Sun (sunkun@szbl.ac.cn)
 * This program is part of the Msuite package, adapted from Ktrim
 * Date: Jan 2020
 *
 * The conversion log's rule:
 *   read 1:
 *	   @LINE_NUMBER+S|xx;xx$ => for reads with endC and C>T changes, 'S' is its quality score
 *	   @LINE_NUMBER+xx;xx$	 => for reads without endC
 *	   @LINE_NUMBER+$		 => for reads without endC and conversions
 *   read 2:
 *	   @S|xx;xx$ => for reads with frontG and G>A changes, 'S' is its quality score
 *	   @xx;xx$	 => for reads without frontG
 *	   @$		 => for reads without frontG and conversions
 *
 * TODO: Use LARGE buffer to store the modified reads per batch then write
 *       it to the output files after the multi-thread trimming/conversion
**/

/*
 * use dynamic max_mismatch as the covered size can range from 3 to a large number such as 50,
 * so use 4 is not good
*/
bool check_mismatch_dynamic_PE( const string & s1, string & s2, unsigned int pos, const adapter_info* ai ) {
	register unsigned int mis1=0, mis2=0;
	register unsigned int i, len;
	len = s1.length() - pos;
	if( len > ai->adapter_len )
		len = ai->adapter_len;

	register unsigned int max_mismatch_dynamic = len >> 2;
	// here use 1/4 of the total length, use roof(len/4)

	if( (max_mismatch_dynamic<<2) != len )
		++ max_mismatch_dynamic;

	// check mismatch for each read
	const char * p = s1.c_str();
	for( i=0; i!=len; ++i ) {
		if( p[pos+i] != ai->adapter_r1[i] ) {
			++ mis1;
			if( mis1 > max_mismatch_dynamic )
				return false;
		}
	}
	p = s2.c_str();
	for( i=0; i!=len; ++i ) {
		if( p[pos+i] != ai->adapter_r2[i] ) {
			++ mis2;
			if( mis2 > max_mismatch_dynamic )
				return false;
		}
	}
	// check total mismatch
	max_mismatch_dynamic = (len+1) >> 1;
	if( mis1 + mis2 > max_mismatch_dynamic )
		return false;

	return true;
}


int main( int argc, const char *argv[] ) {
	if( argc < 5 ) {
		cerr << "\nUsage: " << argv[0] << " <r1.fq> <r2.fq> <cycle> <out.prefix> "
			 << "[mode=0|3|4] [thread=1] [min.length=36] [min.quality=53] [library=illumina]\n\n"

			 << "This program is part of Msuite and is designed to do fastq statistics, quality-trimming,\n"
			 << "adapter-trimming and C->T/G->A conversions for Paired-End reads generated by illumina sequencers.\n\n"

			 << "Run modes:\n"
			 << "  0. Do not perform any conversions. Usable for normal DNA/RNA-seq alignment.\n"
			 << "  3. Do C>T (G>A) for all C (G) sites in read1 (read2). Usable for 3-letter BS-seq data.\n"
			 << "  4. Do C>T (G>A) for C (G) in CpG sites in read1 (read2). Usable for 4-letter TAPS data.\n\n"

			 << "Default parameters:\n"
			 << "  mode: 0\n"
			 << "  min.length: 36\n"
			 << "  min.quality: 53 (33+20 for phred33('!') scoring system)\n\n"

			 << "Other commonly used Phred scoring systems are 35('#') and 64('@').\n"
			 << "You may need to set this parameter manually based on your data.\n\n"
			 << "By default, illumina adapters are used:\n\n"
			 << "  5': ACACTCTTTCCCTACACGACGCTCTTCCGATCT\n"
			 << "  3': AGATCGGAAGAGCGGTTCAGCAGGAATGCCGAG\n\n"
			 << "However, Nextera adapters are also supported:\n\n"\
			 << "  5': CTGTCTCTTATACACATCT\n"
			 << "  3': CTGTCTCTTATACACATCT\n\n"
			 << "Sequencing model (built-in):\n\n"
			 << "              *read1 -->\n"
			 << "  5'adapter - NNNNNNNNNNsequenceNNNNNNNNNN - 3'adapter\n"
			 << "                                <-- read2*\n\n";

		return 2;
	}

	unsigned int  mode = 0;
	unsigned int  thread = 1;
	unsigned int  min_length = 36;
	unsigned char quality = 53;
	const char *libraryKit;
	const adapter_info* ai;
	unsigned int  cycle = atoi( argv[3] );
	if( cycle == 0 ) {
		cerr << "Error: Unacceptable cycle!\n";
		exit(1);
	}
	if( argc > 5 ) {
		mode = atoi( argv[5] );
		if( argc > 6) {
			thread = atoi( argv[6] );
			if( argc > 7 ) {
				min_length = atoi( argv[7] );
				if( argc > 8 ) {
					quality = (unsigned char) atoi( argv[8] );
					if( argc > 9 ) {
						libraryKit = argv[9];
					} else {
						libraryKit = "illumina";
					}
				}
			}
		}
	}
	if( mode != 0 && mode !=3 && mode != 4 ) {
		cerr << "Error: invalid run mode! Must be 0, 3, or 4!\n";
		return 100;
	}
	if( thread == 0 ) {
		cerr << "Warning: thread is set to 0! I will use all threads instead.\n";
		thread = omp_get_max_threads();
	}
	if( min_length == 0 ) {
		cerr << "Error: invalid min_length! Must be a positive number!\n";
		return 101;
	}
	if( quality == 0 ) {
		cerr << "Error: invalid quality! Must be a positive number!\n";
		return 102;
	}
	if( strcmp(libraryKit, "illumina")==0 || strcmp(libraryKit, "Illumina")==0 ) {
		ai = &illumina_adapter;
	} else if ( strcmp(libraryKit, "nextera")==0 || strcmp(libraryKit, "Nextera")==0 ) {
		ai = &nextera_adapter;
	} else if ( strcmp(libraryKit, "bgi")==0 || strcmp(libraryKit, "BGI")==0 ) {
		ai = &bgi_adapter;
	} else {
		cerr << "Error: invalid library kit! Currently only supports illumina and nextera!\n";
		return 103;
	}

	string *id1   = new string [READS_PER_BATCH];
	string *id2   = new string [READS_PER_BATCH];
	string *seq1  = new string [READS_PER_BATCH];
	string *seq2  = new string [READS_PER_BATCH];
	string *qual1 = new string [READS_PER_BATCH];
	string *qual2 = new string [READS_PER_BATCH];
	string unk;

	int *dropped	  = new int [thread];
	int *real_adapter = new int [thread];
	int *tail_adapter = new int [thread];

	fastqstat * AllR1stat = new fastqstat[ cycle ];
	memset( AllR1stat, 0, cycle*sizeof(fastqstat) );
	fastqstat * AllR2stat = new fastqstat[ cycle ];
	memset( AllR2stat, 0, cycle*sizeof(fastqstat) );

	// buffer for storing the modified reads per thread
	char ** buffer1 = new char * [thread];
	char ** buffer2 = new char * [thread];
	int  * b1stored = new int	[thread];
	int  * b2stored = new int	[thread];
	fastqstat **R1stat = new fastqstat * [thread];
	fastqstat **R2stat = new fastqstat * [thread];
	for(unsigned int i=0; i!=thread; ++i) {
		buffer1[i] = new char[ BUFFER_SIZE_PER_BATCH_READ ];
		buffer2[i] = new char[ BUFFER_SIZE_PER_BATCH_READ ];

		R1stat[i]  = new fastqstat [ cycle ];
		R2stat[i]  = new fastqstat [ cycle ];

		dropped[i] = 0;
		real_adapter[i] = 0;
		tail_adapter[i] = 0;
	}

	cerr << "Loading files ...\n";

    // deal with multiple input files
    vector<string> R1s, R2s;
    string fileName="";
    for(unsigned int i=0; argv[1][i]!='\0'; ++i) {
        if( argv[1][i] == FILE_SEPARATOR ) {
            R1s.push_back( fileName );
            fileName.clear();
        } else {
            fileName += argv[1][i];
        }
    }
    R1s.push_back( fileName );

    fileName.clear();
    for(unsigned int i=0; argv[2][i]!='\0'; ++i) {
        if( argv[2][i] == FILE_SEPARATOR ) {
            R2s.push_back( fileName );
            fileName.clear();
        } else {
            fileName += argv[2][i];
        }
    }
    R2s.push_back( fileName );
    
    if( R1s.size() != R2s.size() ) {
        cerr << "Fatal error: Read1 and Read2 do not contain equal sized files!\n";
        return 10;
    }
    unsigned int totalFiles = R1s.size();
    cout << "INFO: " << totalFiles << " paired fastq files will be loaded.\n";

    string base = argv[4];
	ofstream fout1( (base+".R1.fq").c_str() ), fout2( (base+".R2.fq").c_str() );
	if( fout1.fail() || fout2.fail() ) {
		cout << "Error: write file failed!\n";
		fout1.close();
        fout2.close();
		return 3;
	}
	// set HEX format number output
	fout1.setf(ios::hex, ios::basefield);
	fout2.setf(ios::hex, ios::basefield);
    
    ifstream fq1, fq2;
    register unsigned int line = 1;
    for( unsigned int fileCnt=0; fileCnt!=totalFiles; ++ fileCnt ) {
        fq1.open( R1s[fileCnt] );
        fq2.open( R2s[fileCnt] );
        if( fq1.fail() || fq2.fail() ) {
            cout << "Error: open fastq file failed!\n";
            fq1.close();
            fq2.close();
            fout1.close();
            fout2.close();
            return 11;
        }

        while( true ) {
            // get fastq reads
            unsigned int loaded = 0;
            while( true ) {
                getline( fq1, id1  [ loaded ] );
                if( fq1.eof() )break;
                getline( fq1, seq1 [ loaded ] );
                getline( fq1, unk );
                getline( fq1, qual1[ loaded ] );

                ++ loaded;
                if( loaded == READS_PER_BATCH )
                    break;
            }
            //cerr << "loaded: " << loaded << '\n';
            if( loaded == 0 )
                break;
            for(register unsigned int i=0; i!=loaded; ++i ) {
                getline( fq2, id2  [ i ] );
                getline( fq2, seq2 [ i ] );
                getline( fq2, unk );
                getline( fq2, qual2[ i ] );

				if( seq2[i].size() != seq1[i].size() ) {
					if( seq2[i].size() > seq1[i].size() ) {
						seq2[i].resize(  seq1[i].size()  );
						qual2[i].resize( qual1[i].size() );
					} else {
						seq1[i].resize(  seq2[i].size()  );
						qual1[i].resize( qual2[i].size() );
					}
				}
            }

            // start parallalization
            omp_set_num_threads( thread );
            #pragma omp parallel
            {
                unsigned int tn = omp_get_thread_num();
                unsigned int start = loaded * tn / thread;
                unsigned int end   = loaded * (tn+1) / thread;

                // normalization
                b1stored[tn] = 0;
                b2stored[tn] = 0;
                memset( R1stat[tn], 0, cycle*sizeof(fastqstat) );
                memset( R2stat[tn], 0, cycle*sizeof(fastqstat) );
            
                string conversionLog;
                register int i, j;
                register unsigned int last_seed;
                vector<unsigned int> seed;
                vector<unsigned int> :: iterator it;
                const char *p, *q;
                char *conversion = new char [MAX_CONVERSION];
                char numstr[10]; // enough to hold all numbers up to 99,999,999 plus ':'

                for( unsigned int ii=start; ii!=end; ++ii ) {
                    // fqstatistics
                    p = seq1[ii].c_str();
                    q = seq2[ii].c_str();
                    for( i=0; i!=cycle; ++i ) {
                        switch ( p[i] ) {
                            case 'a':
                            case 'A': R1stat[tn][i].A ++; break;
                            case 'c':
                            case 'C': R1stat[tn][i].C ++; break;
                            case 'g':
                            case 'G': R1stat[tn][i].G ++; break;
                            case 't':
                            case 'T': R1stat[tn][i].T ++; break;
                            default : R1stat[tn][i].N ++; break;
                        }
                        switch ( q[i] ) {
                            case 'a':
                            case 'A': R2stat[tn][i].A ++; break;
                            case 'c':
                            case 'C': R2stat[tn][i].C ++; break;
                            case 'g':
                            case 'G': R2stat[tn][i].G ++; break;
                            case 't':
                            case 'T': R2stat[tn][i].T ++; break;
                            default : R2stat[tn][i].N ++; break;
                        }
                    }

                    // quality control
                    p = qual1[ii].c_str();
                    q = qual2[ii].c_str();
                    for( i=qual1[ii].length()-1; i; --i ) {
                        if( p[i]>=quality && q[i]>=quality ) break;
                    }
                    ++ i;
                    if( i < min_length ) { // not long enough
                        ++ dropped[ tn ];
                        continue;
                    }
                    seq1[ii].resize(  i );
                    seq2[ii].resize(  i );
                    qual1[ii].resize( i );
                    qual2[ii].resize( i );

                    // looking for seed target, 1 mismatch is allowed for these 2 seeds
                    // which means seq1 and seq2 at least should take 1 perfect seed match
                    seed.clear();
                    for( i=0; (i=seq1[ii].find(ai->adapter_index, i)) != string::npos; ++i )
                        seed.push_back( i );
                    for( i=0; (i=seq2[ii].find(ai->adapter_index, i)) != string::npos; ++i )
                        seed.push_back( i );

                    sort( seed.begin(), seed.end() );

                    last_seed = impossible_seed;	// a position which cannot be in seed
                    for( it=seed.begin(); it!=seed.end(); ++it ) {
                        if( *it != last_seed ) {
                        // as there maybe the same value in seq1_seed and seq2_seed,
                        // use this to avoid re-calculate that pos
                            if( check_mismatch_dynamic_PE( seq1[ii], seq2[ii], *it, ai) )
                                break;
                            last_seed = *it;
                        }
                    }
                    if( it != seed.end() ) {	// adapter found
                        ++ real_adapter[tn];
                        if( *it >= min_length )	{
                            seq1[ii].resize(  *it );
                            seq2[ii].resize(  *it );
                            qual1[ii].resize( *it );
                            qual2[ii].resize( *it );
                        } else {	// drop this read as its length is not enough
                            ++ dropped[tn];
                            continue;
                        }
                    } else {	// seed not found, now check the tail 2 or 1, if perfect match, drop these 2
                        i = seq1[ii].length() - 2;
                        p = seq1[ii].c_str();
                        q = seq2[ii].c_str();
                        if( p[i]==ai->adapter_r1[0] && p[i+1]==ai->adapter_r1[1] &&
                                    q[i]==ai->adapter_r2[0] && q[i+1]==ai->adapter_r2[1] ) {
                            if( i < min_length ) {
                                ++ dropped[tn];
                                continue;
                            }
                            seq1[ii].resize( i );
                            seq2[ii].resize( i );
                            qual1[ii].resize( i );
                            qual2[ii].resize( i );

                            ++ tail_adapter[tn];
                        } else {	// tail 2 is not good, check tail 1
                            ++ i;
                            if( p[i] == ai->adapter_r1[0] && q[i] == ai->adapter_r2[0] ) {
                                if( i < min_length ) {
                                    ++ dropped[tn];
                                    continue;
                                }
                                seq1[ii].resize(  i );
                                seq2[ii].resize(  i );
                                qual1[ii].resize( i );
                                qual2[ii].resize( i );

                                ++ tail_adapter[tn];
                            }
                        }
                    }

                    //check if there is any white space in the IDs; if so, remove all the data after the whitespace
                    j = id1[ii].size();
                    p = id1[ii].c_str();
                    for( i=1; i!=j; ++i ) {
                        if( p[i]==' ' || p[i]=='\t' ) {	// white space, then trim ID
                            id1[ii].resize( i );
                            break;
                        }
                    }
                    j = id2[ii].size();
                    q = id2[ii].c_str();
                    for( i=0; i!=j; ++i ) {
                        if( q[i]==' ' || q[i]=='\t' ) {	// white space, then trim ID
                            id2[ii].resize( i );
                            break;
                        }
                    }

                    // do C->T and G->A conversion
                    if( mode == 0 ) {	// no need to do conversion
                        /*
                        fout1 << id1 << '\n' << seq1 << "\n+\n" << qual1 << '\n';
                        fout2 << id2 << '\n' << seq2 << "\n+\n" << qual2 << '\n';
                        */
                        b1stored[tn] += sprintf( buffer1[tn]+b1stored[tn], "%s\n%s\n+\n%s\n",
                                    id1[ii].c_str(), seq1[ii].c_str(), qual1[ii].c_str() );
                        b2stored[tn] += sprintf( buffer2[tn]+b2stored[tn], "%s\n%s\n+\n%s\n",
                                    id2[ii].c_str(), seq2[ii].c_str(), qual2[ii].c_str() );
                    } else if( mode == 3 ) {	// in this implementation, id1 and id2 are different!!!
                        // modify id1 to add line number (to facilitate removing ambigous step)
                        // in mode 3, there is NO endC and frontG issues
                        id1[ii][0] = CONVERSION_LOG_END;
                        j = seq1[ii].size();	// seq1 and seq2 are of the same size
                        conversionLog = LINE_NUMBER_SEPARATOR;
                        for( i=0; i!=j; ++i ) {
                            if( seq1[ii][i] == 'C' ) {
                                seq1[ii][i] = 'T';
                                sprintf( numstr, "%x%c", i, CONVERSION_LOG_SEPARATOR );
                                conversionLog += numstr;
                            }
                        }
                        if( conversionLog.back() == CONVERSION_LOG_SEPARATOR )
                            conversionLog.pop_back();
                        /*fout1 << NORMAL_SEQNAME_START << line << conversionLog << id1 << '\n'
                                << seq1 << "\n+\n" << qual1 << '\n';*/
                        b1stored[tn] += sprintf( buffer1[tn]+b1stored[tn], "%c%x%s%s\n%s\n+\n%s\n",
                                                    NORMAL_SEQNAME_START, line+ii, conversionLog.c_str(),
                                                    id1[ii].c_str(), seq1[ii].c_str(), qual1[ii].c_str() );

                        id2[ii][0] = CONVERSION_LOG_END;
                        conversionLog = NORMAL_SEQNAME_START;	// read2 does not record line number
                        for( i=0; i!=j; ++i ) {
                            if( seq2[ii][i] == 'G' ) {
                                seq2[ii][i] = 'A';
                                sprintf( numstr, "%x%c", i, CONVERSION_LOG_SEPARATOR );
                                conversionLog += numstr;
                            }
                        }
                        if( conversionLog.back() == CONVERSION_LOG_SEPARATOR )
                            conversionLog.pop_back();
                        // do not add line number to read 2
                        /*fout2 << conversionLog << id2 << '\n' << seq2 << "\n+\n" << qual2 << '\n';*/
                        b2stored[tn] += sprintf( buffer2[tn]+b2stored[tn], "%s%s\n%s\n+\n%s\n",
                            conversionLog.c_str(), id2[ii].c_str(), seq2[ii].c_str(), qual2[ii].c_str() );
                    } else if ( mode == 4 ) {	// this is the major task for EMaligner
                        // modify id1 to add line number (to facilitate the removing ambigous step)
                        // check seq1 for C>T conversion
                        id1[ii][0] = CONVERSION_LOG_END;
                        conversionLog = LINE_NUMBER_SEPARATOR;
                        j = seq1[ii].size()-1;
                        if( seq1[ii].back() == 'C' ) { //ther is a 'C' and the end, discard it (but record its Quality score);
                            //otherwise it may introduce a mismatch in alignment
                            conversionLog += qual1[ii].back();
                            conversionLog += KEEP_QUAL_MARKER;
                            seq1[ii].pop_back();
                            qual1[ii].pop_back();
                        }
                        for( i=0; i!=j; ++i ) {
                            if( seq1[ii][i]=='C' && seq1[ii][i+1]=='G' ) {
                                seq1[ii][i] = 'T';
                                sprintf( numstr, "%x%c", i, CONVERSION_LOG_SEPARATOR );
                                conversionLog += numstr;
                            }
                        }
                        if( conversionLog.back() == CONVERSION_LOG_SEPARATOR )
                            conversionLog.pop_back();
                        /*fout1 << NORMAL_SEQNAME_START << line << conversionLog << id1 << '\n'
                                << seq1 << "\n+\n" << qual1 << '\n';*/
                        b1stored[tn] += sprintf( buffer1[tn]+b1stored[tn], "%c%x%s%s\n%s\n+\n%s\n",
                                    NORMAL_SEQNAME_START, line+ii, conversionLog.c_str(),
                                    id1[ii].c_str(), seq1[ii].c_str(), qual1[ii].c_str() );
                        // format for ID1:
                        // if there is a C at the end
                        //	@line_number '+' x| C1;C2;C3$ raw_seq_name
                        //	the | is the marker for the existence of tail 'C' and 'x' is its quality score
                        //	if exists, | is ALWAYS two bytes after '+' (use this to test its existence)
                        // if there is No C at the end
                        //	@line_number '+' C1&C2&C3$ raw_seq_name
                        //
                        // All the numbers in line_number and C1,C2,C3... are HEX

                        // check seq2 for G>A conversion
                        id2[ii][0] = CONVERSION_LOG_END;
                        conversionLog = NORMAL_SEQNAME_START;
                        if( seq2[ii][0] == 'G' ) { //'G' at the front, discard it (but record its Quality score)
                            conversionLog += qual2[ii][0];
                            conversionLog += KEEP_QUAL_MARKER;
                        }
                        j = seq2[ii].size();
                        for( i=1; i!=j; ++i ) {
                            if( seq2[ii][i]=='G' && seq2[ii][i-1]=='C' ) {
                                seq2[ii][i] = 'A';
                                sprintf( numstr, "%x%c", i, CONVERSION_LOG_SEPARATOR );
                                conversionLog += numstr;
                            }
                        }
                        if( conversionLog.back() == CONVERSION_LOG_SEPARATOR )
                            conversionLog.pop_back();
                        if( seq2[ii][0] != 'G' ) {
                            /*fout2 << conversionLog << id2 << '\n' << seq2 << "\n+\n" << qual2 << '\n';*/
                            b2stored[tn] += sprintf( buffer2[tn]+b2stored[tn], "%s%s\n%s\n+\n%s\n",
                                            conversionLog.c_str(), id2[ii].c_str(), seq2[ii].c_str(), qual2[ii].c_str() );
                        } else {
                            p = seq2[ii].c_str();
                            q = qual2[ii].c_str();
                            /*fout2 << conversionLog << id2 << '\n' << p+1 << "\n+\n" << q+1 << '\n';*/
                            b2stored[tn] += sprintf( buffer2[tn]+b2stored[tn], "%s%s\n%s\n+\n%s\n",
                                                    conversionLog.c_str(), id2[ii].c_str(), p+1, q+1 );
                        }
                        // format for ID2:
                        // if there is a G at the front
                        //	@x| C1&C2&C3$ raw_seq_name
                        //	if exists, | is ALWAYS two bytes after '@' (use this to test its existence)
                        // if there is No G at the front
                        //	@C1&C2&C3$ raw_seq_name
                        //
                        // All the numbers in line_number and C1,C2,C3... are HEX
                    }
                }
            }	// parallel body
            // write output and update fastq statistics
            for(register unsigned int i=0; i!=thread; ++i ) {
                fout1 << buffer1[i];
			}
            for(register unsigned int i=0; i!=thread; ++i ) {
                fout2 << buffer2[i];
			}

            for(register unsigned int i=0; i!=thread; ++i ) {
                for( unsigned int j=0; j!=cycle; ++j ) {
                    AllR1stat[j].A += R1stat[i][j].A;
                    AllR1stat[j].C += R1stat[i][j].C;
                    AllR1stat[j].G += R1stat[i][j].G;
                    AllR1stat[j].T += R1stat[i][j].T;
                    AllR1stat[j].N += R1stat[i][j].N;

                    AllR2stat[j].A += R2stat[i][j].A;
                    AllR2stat[j].C += R2stat[i][j].C;
                    AllR2stat[j].G += R2stat[i][j].G;
                    AllR2stat[j].T += R2stat[i][j].T;
                    AllR2stat[j].N += R2stat[i][j].N;
                }
            }
            line += loaded;
            cerr << '\r' << line-1 << " reads loaded";

            if( fq1.eof() ) break;
        }
        fq1.close();
        fq2.close();
    }

	fout1.close();
	fout2.close();

	cerr << "\rDone: " << line-1 << " lines processed.\n";

	// write trim.log
	ofstream fout( "Msuite.trim.log" );
	if( fout.fail() ) { 
		cerr << "Error: cannot write log file!\n";
		return 4;
	}
	int dropped_all=0, real_all=0, tail_all=0;
	for( unsigned int i=0; i!=thread; ++i ) {
		dropped_all += dropped[i];
		real_all += real_adapter[i];
		tail_all += tail_adapter[i];
	}
	fout << line << '\n'	// total
		 << "Dropped : " << dropped_all << '\n'
		 << "Aadaptor: " << real_all	<< '\n'
		 << "Tail Hit: " << tail_all	<< '\n';
	fout.close();

	// write fqstatistics
	fout.open( "R1.fqstat" );
	if( fout.fail() ) {
		cerr << "Error: cannot write R1.fqstat file!\n";
		return 5;
	}
	fout << "Cycle\tA\tC\tG\tT\tN\n";
	for( unsigned int j=0; j!=cycle; ++j ) {
		fout << j+1 << '\t' << AllR1stat[j].A << '\t' << AllR1stat[j].C << '\t'<< AllR1stat[j].G
				<< '\t' << AllR1stat[j].T << '\t'<< AllR1stat[j].N << '\n';
	}
	fout.close();

	fout.open( "R2.fqstat" );
	if( fout.fail() ) {
		cerr << "Error: cannot write R2.fqstat file!\n";
		return 5;
	}
	fout << "Cycle\tA\tC\tG\tT\tN\n";
	for( unsigned int j=0; j!=cycle; ++j ) {
		fout << j+1 << '\t' << AllR2stat[j].A << '\t' << AllR2stat[j].C << '\t'<< AllR2stat[j].G
				<< '\t' << AllR2stat[j].T << '\t'<< AllR2stat[j].N << '\n';
	}
	fout.close();

	//free memory
	for(unsigned int i=0; i!=thread; ++i) {
		delete buffer1[i];
		delete buffer2[i];
		delete R1stat[i];
		delete R2stat[i];
	}
	delete [] buffer1;
	delete [] buffer2;
	delete [] R1stat;
	delete [] R2stat;
	delete [] AllR1stat;
	delete [] AllR2stat;

	return 0;
}

